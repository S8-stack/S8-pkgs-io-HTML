package com.qx.back.io.ssl.outbound;

import java.nio.ByteBuffer;

import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLEngineResult.Status;
import javax.net.ssl.SSLException;

/**
 * Just flush bytes, but do not require re-launching 
 * unsafeWrap after that
 * 
 * 
 */
public class Closing extends SSL_OutboundMode {
	
	private SSLEngine engine;
	
	private ByteBuffer applicationBuffer;

	private ByteBuffer networkBuffer;
	
	private SSL_OutboundMode flushing;
	

	public Closing(SSL_Outbound inbound) {
		super(inbound);
		
	}

	@Override
	public void bind() {
		engine = outbound.engine;
		applicationBuffer = outbound.applicationBuffer;
		networkBuffer = outbound.networkBuffer;
		flushing = outbound.flushing;
	}

	@Override
	public SSL_OutboundMode run() {
		
		/*
		 * Closing this side of the engine
		 */
		engine.closeOutbound();
		
		
		/* wrapping */
		try {
			boolean isWrapCompleted = false;
			while(!isWrapCompleted) {
			
				/*
				 * (JAVA doc) states that:
				 * 
				 * In all cases, closure handshake messages are generated by the engine, and
				 * wrap() should be repeatedly called until the resulting SSLEngineResult's
				 * status returns "CLOSED", or isOutboundDone() returns true.
				 * 
				 */
				SSLEngineResult result = engine.wrap(applicationBuffer, networkBuffer);
				
				if(result.getStatus()==Status.CLOSED || engine.isOutboundDone() || result.bytesProduced()==0) {
					isWrapCompleted = true;
				}
			}
			
			/*
			 * All data obtained from the wrap() method should be sent to the peer.
			 */
			return flushing;	
		} 
		catch (SSLException e) {
			e.printStackTrace();
		}
		
		
		// stop here, with no callback
		return null;
	}

}
