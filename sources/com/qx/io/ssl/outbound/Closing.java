package com.qx.io.ssl.outbound;

import java.nio.ByteBuffer;

import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLEngineResult.Status;
import javax.net.ssl.SSLException;

/**
 * Just flush bytes, but do not require re-launching 
 * unsafeWrap after that
 * 
 * 
 */
public class Closing extends SSL_OutboundMode {
	
	private SSLEngine engine;
	
	private ByteBuffer applicationBuffer;

	private ByteBuffer networkBuffer;
	
	private Flushing flushing;
	

	public Closing() {
		super();
	}


	public class Task extends SSL_OutboundMode.Task {
		
		@Override
		public SSL_OutboundMode.Task run() {
			
			/*
			 * Closing this side of the engine
			 */
			engine.closeOutbound();
			
			
			/* wrapping */
			try {
				boolean isWrapCompleted = false;
				while(!isWrapCompleted) {
				
					/*
					 * (JAVA doc) states that:
					 * 
					 * In all cases, closure handshake messages are generated by the engine, and
					 * wrap() should be repeatedly called until the resulting SSLEngineResult's
					 * status returns "CLOSED", or isOutboundDone() returns true.
					 * 
					 */
					SSLEngineResult result = engine.wrap(applicationBuffer, networkBuffer);
					
					if(result.getStatus()==Status.CLOSED || engine.isOutboundDone() || result.bytesProduced()==0) {
						isWrapCompleted = true;
					}
				}
				
				/*
				 * All data obtained from the wrap() method should be sent to the peer.
				 */
				return flushing.new Task(null);	
			} 
			catch (SSLException e) {
				e.printStackTrace();
			}
			
			
			// stop here, with no callback
			return null;
		}
	}
	

	@Override
	public void bind(SSL_Outbound outbound) {
		engine = outbound.engine;
		flushing = outbound.flushing;
	}
	
	
	public void setNetworkBuffer(ByteBuffer buffer) {
		networkBuffer = buffer;
	}
	
	public void setApplicationBuffer(ByteBuffer buffer) {
		applicationBuffer = buffer;
	}

}
