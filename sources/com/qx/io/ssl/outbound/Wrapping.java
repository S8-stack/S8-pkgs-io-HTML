package com.qx.io.ssl.outbound;

import java.nio.ByteBuffer;

import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLException;

import com.qx.base.reactive.QxIOReactive;
import com.qx.io.ssl.SSL_Endpoint;
import com.qx.io.ssl.inbound.SSL_Inbound;

public class Wrapping extends SSL_OutboundMode {

	private QxIOReactive sender;

	private String name;

	private SSL_Endpoint endpoint;

	private SSLEngine engine;

	private SSL_Outbound outbound;
	private SSL_Inbound inbound;

	private ByteBuffer applicationBuffer;

	private boolean isVerbose;

	private ByteBuffer networkBuffer;

	private Pushing pushing;
	private Flushing flushing;
	private Closing closing;
	private RunningDelegates runningTasks;
	private UnwrapRequesting requestUnwrapping;

	public Wrapping() {
		super();
	}

	
	public class Task extends SSL_OutboundMode.Task {
		

		@Override
		public SSL_OutboundMode.Task run() {

			/*
			 * If closed, immediately fork to a specific closing procedure  
			 */
			if(endpoint.isClosed) {
				return closing.new Task();
			}

			/* <retrieve> */
			/*
			 * application output buffer -> WRITE
			 * NB: Application output buffer is left in read mode all the time,
			 * except in this state scope.
			 */
			applicationBuffer.compact();

			sender.on(applicationBuffer);

			/* application output buffer -> READ */
			applicationBuffer.flip();

			/* </retrieve> */

			try {

				if(isVerbose) {
					System.out.println("\t--->"+name+" is wrapping... ");
				}

				/* wrapping */
				SSLEngineResult wrapResult = engine.wrap(applicationBuffer, networkBuffer);

				if(isVerbose) {
					System.out.println(name+": "+wrapResult);
				}

				// end point listening to result for updating phase
				endpoint.onResult(wrapResult);



				


				/* <handshake-status> */
				switch(wrapResult.getHandshakeStatus()) {

				/* 
				 * run delegated tasks and then see what's required next 
				 */
				case NEED_TASK: 
					
					switch(wrapResult.getStatus()) {

					case BUFFER_UNDERFLOW: 
					case BUFFER_OVERFLOW: 
					case OK:
						break; // discarded
						
					case CLOSED: 
						/*
						 * In all cases, closure handshake messages are generated by the engine, and 
						 * wrap() should be repeatedly called until the resulting SSLEngineResult's status 
						 * returns "CLOSED", or isOutboundDone() returns true. 
						 * All data obtained from the wrap() method should be sent to the peer.
						 */
						// close must be detected separately. Left here for security purposes.
						return null;
					}
					
					return runningTasks.new Task(this);

				case NEED_WRAP: 
					
					switch(wrapResult.getStatus()) {

					case BUFFER_UNDERFLOW: // not supposed to happen
						throw new SSLException("Strange error: BUFFER_UNDERFLOW while wrapping");

						/* 
						 * Handle the <code>wrap(applicationOutput, networkOutput)</code> 
						 * case when the SSLEngine was not able to process the operation 
						 * because there are not enough bytes available in the destination 
						 * buffer to hold the result.
						 */
					case BUFFER_OVERFLOW: 

						/* Network output is not even half-filled, so assume that it is 
						 * under-sized 
						 */
						if(!isNetworkBufferHalfFilled()) {
							doubleNetworkBufferCapacity();
							return this; /* retry wrapping */
						}
						/*
						 * Network output is almost filled, so best solution is to send. But since we
						 * are in handshaking phase, must return to unsafeWrap once networkBuffer bytes have
						 * been written out
						 */
						else {
							return pushing.new Task();
						}

					case CLOSED: 
						/*
						 * In all cases, closure handshake messages are generated by the engine, and 
						 * wrap() should be repeatedly called until the resulting SSLEngineResult's status 
						 * returns "CLOSED", or isOutboundDone() returns true. 
						 * All data obtained from the wrap() method should be sent to the peer.
						 */
						// close must be detected separately. Left here for security purposes.
						return null;


					case OK:
						/*
						 * Since we already are in wrap mode, try concatenating the next wrap into the
						 * networkBuffer, so try to wrap again
						 */
						break;
					}
					
					
					// default behavior
					return this;

				case NEED_UNWRAP:
				case NEED_UNWRAP_AGAIN: 
					
					switch(wrapResult.getStatus()) {

					case BUFFER_UNDERFLOW: // not supposed to happen
						throw new SSLException("Strange error: BUFFER_UNDERFLOW while wrapping");

						/* 
						 * Handle the <code>wrap(applicationOutput, networkOutput)</code> 
						 * case when the SSLEngine was not able to process the operation 
						 * because there are not enough bytes available in the destination 
						 * buffer to hold the result.
						 */
					case BUFFER_OVERFLOW: 

						/* Network output is not even half-filled, so assume that it is 
						 * under-sized 
						 */
						if(!isNetworkBufferHalfFilled()) {
							doubleNetworkBufferCapacity();
							return this; /* retry wrapping */
						}
						/*
						 * Network output is almost filled, so best solution is to send. But since we
						 * are in handshaking phase, must return to unsafeWrap once networkBuffer bytes have
						 * been written out
						 */
						else {
							return pushing.new Task();
						}

					case CLOSED: return null;
					case OK: break;
					}
					
					/*
					 * Flush all network bytes and then request unwrapping 
					 */
					return flushing.new Task(requestUnwrapping.new Task());

				case FINISHED: 

					/*
					 * End of handshaking, start independent working of inbound/outbound. Since
					 * Inbound MIGHT have been left in idle mode, wake it up to ensure it is active
					 */
					inbound.resume();

					// -> continue to next case


				case NOT_HANDSHAKING: // application data

					/*
					 * no more handshaking is requested, so end up here. But we are now in stream mode
					 * (handshake is now completed), so ALWAYS ask for more wrapping. 
					 * 
					 * NOTE: if applicationBuffer is depleted, then networkBuffer will remain empty and
					 * wrap() method will stop by itself.
					 */
					
					switch(wrapResult.getStatus()) {

					case BUFFER_UNDERFLOW: // not supposed to happen
						throw new SSLException("Strange error: BUFFER_UNDERFLOW while wrapping");

						/* 
						 * Handle the <code>wrap(applicationOutput, networkOutput)</code> 
						 * case when the SSLEngine was not able to process the operation 
						 * because there are not enough bytes available in the destination 
						 * buffer to hold the result.
						 */
					case BUFFER_OVERFLOW: 

						/* Network output is not even half-filled, so assume that it is 
						 * under-sized 
						 */
						if(!isNetworkBufferHalfFilled()) {
							doubleNetworkBufferCapacity();
							return this; /* retry wrapping */
						}
						/*
						 * Network output is almost filled, so best solution is to send. But since we
						 * are in handshaking phase, must return to unsafeWrap once networkBuffer bytes have
						 * been written out
						 */
						else {
							return pushing.new Task();
						}

					case CLOSED: 
						// close must be detected separately. Left here for security purposes.
						return null;


					case OK: break;
					}
					
					
					// nothing produced, so we don't expect more, so push
					if(wrapResult.bytesProduced()==0) {
						if(networkBuffer.position()>0) {
							return pushing.new Task();		
						}
						else { // everything has been pushed
							outbound.stop();
							return null; // go back to idle state
						}
					}
					// try to get more before pushing (greedy)
					else { 
						return this;
					}

				}
				/* </handshake-status> */
			}
			catch (SSLException e) {
				if(isVerbose) {
					System.out.println("[Wrapping]: SSL_Exception causes endpoint to close.");
					e.printStackTrace();
				}
				// Everything went wrong, so try launching the closing procedure
				endpoint.isClosed = true;
				return closing.new Task();
			}
			
			
			return null; // default
		}
		
		
	}
	
	
	@Override
	public void bind(SSL_Outbound outbound) {
		
		this.outbound = outbound;
		
		name = outbound.name;
		isVerbose = outbound.isVerbose;
		endpoint = outbound.endpoint;
		engine = outbound.engine;
		sender = outbound.sender;
		inbound = endpoint.inbound;
		
		// modes
		pushing = outbound.pushing;
		flushing = outbound.flushing;
		closing = outbound.closing;
		runningTasks = outbound.runningTasks;
		requestUnwrapping = outbound.requestUnwrapping;
	}

	private boolean isNetworkBufferHalfFilled() {
		return networkBuffer.position()>networkBuffer.capacity()/2;
	}


	/**
	 * Double buffer capacity
	 * 
	 * @param engine
	 * @throws SSLException
	 */
	private void doubleNetworkBufferCapacity() throws SSLException {

		int increasedSize = 2 * networkBuffer.capacity();
		if (isVerbose) {
			System.out.println("[SSL] " +name+ " : Network output buffer capacity increased to " + increasedSize);
		}
		if (increasedSize > 4 * engine.getSession().getPacketBufferSize()) {
			throw new SSLException(
					"[SSL_Inbound] networ output capacity is now 4x getPacketBufferSize. " + "Seen as excessive");
		}

		ByteBuffer extendedBuffer = ByteBuffer.allocate(increasedSize);
		networkBuffer.flip();
		extendedBuffer.put(networkBuffer);
		//extendedBuffer.compact(); // left in write mode
		
		// publish new network buffer
		outbound.setNetworkBuffer(extendedBuffer);
	}
	

	public void setNetworkBuffer(ByteBuffer buffer) {
		networkBuffer = buffer;
	}
	
	public void setApplicationBuffer(ByteBuffer buffer) {
		applicationBuffer = buffer;
	}

}
