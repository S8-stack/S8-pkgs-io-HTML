package com.qx.io.ssl.outbound;

import java.nio.ByteBuffer;

import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLException;

import com.qx.io.ssl.outbound.SSL_Outbound.Process;

public class Wrapping extends SSL_Outbound.Mode {


	//public final static Wrapping MODE = new Wrapping();

	public Wrapping(SSL_Outbound outbound) {
		outbound.super();
	}
	
	@Override
	public String declare() {
		return "is wrapping...";
	}
	

	@Override
	public void run(SSL_Outbound.Process process) {

		if(!getEndpoint().isClosed) {

			/* <retrieve> */

			/*
			 * Wrapping is greedy, i.e. it retrieves as much application data as possible
			 * before retrying to push to the network
			 */
			pump();

			/* </retrieve> */

			try {

				/* wrapping */
				SSLEngineResult wrapResult = getEngine().wrap(getApplicationBuffer(), getNetworkBuffer());

				if(isVerbose()) {
					System.out.println(getName()+": "+wrapResult);
				}

				// end point listening to result for updating phase
				getEndpoint().onResult(wrapResult);

				/* <handshake-status> */
				switch(wrapResult.getHandshakeStatus()) {

				/* 
				 * run delegated tasks and then see what's required next 
				 */
				case NEED_TASK: 

					switch(wrapResult.getStatus()) {

					case BUFFER_UNDERFLOW: // discarded
					case BUFFER_OVERFLOW: // discarded

					case OK:
						process.mode = runDelegates(this);
						break;

					case CLOSED: 
						/*
						 * In all cases, closure handshake messages are generated by the engine, and 
						 * wrap() should be repeatedly called until the resulting SSLEngineResult's status 
						 * returns "CLOSED", or isOutboundDone() returns true. 
						 * All data obtained from the wrap() method should be sent to the peer.
						 */
						// close must be detected separately. Left here for security purposes.

						process.mode = flush(); // release, but need to restart
						break;
					}
					break; // </NEED_TASKS>

				case NEED_WRAP: 

					switch(wrapResult.getStatus()) {

					case BUFFER_UNDERFLOW: // not supposed to happen
						throw new SSLException("Strange error: BUFFER_UNDERFLOW while wrapping");

						/* 
						 * Handle the <code>wrap(applicationOutput, networkOutput)</code> 
						 * case when the SSLEngine was not able to process the operation 
						 * because there are not enough bytes available in the destination 
						 * buffer to hold the result.
						 */
					case BUFFER_OVERFLOW: handleBufferOverflow(process); break;

						

					case CLOSED: 
						/*
						 * In all cases, closure handshake messages are generated by the engine, and 
						 * wrap() should be repeatedly called until the resulting SSLEngineResult's status 
						 * returns "CLOSED", or isOutboundDone() returns true. 
						 * All data obtained from the wrap() method should be sent to the peer.
						 */
						// close must be detected separately. Left here for security purposes.

						// need to come back in flush mode
						process.mode = flush();
						break;


					case OK:
						/*
						 * Since we already are in wrap mode, try concatenating the next wrap into the
						 * networkBuffer, so try to wrap again
						 */
						break; // stay in wrapping mode
					}
					break; // </NEED_WRAP>

				case NEED_UNWRAP:
				case NEED_UNWRAP_AGAIN: 

					switch(wrapResult.getStatus()) {

					case BUFFER_UNDERFLOW: // not supposed to happen
						throw new SSLException("Strange error: BUFFER_UNDERFLOW while wrapping");

						/* 
						 * Handle the <code>wrap(applicationOutput, networkOutput)</code> 
						 * case when the SSLEngine was not able to process the operation 
						 * because there are not enough bytes available in the destination 
						 * buffer to hold the result.
						 */
					case BUFFER_OVERFLOW: handleBufferOverflow(process); break;

					case CLOSED: 
						process.mode = close();
						break;

					case OK: 
						/*
						 * TODO Flush all network bytes and then request unwrapping 
						 */
						process.mode = flush();
						
						// trigger unwrap
						unwrap();
						break;
					}
					break; // </NEED_UNWRAP>

				case FINISHED: 

					/*
					 * End of handshaking, start independent working of inbound/outbound. Since
					 * Inbound MIGHT have been left in idle mode, wake it up to ensure it is active
					 */
					unwrap();
					// -> continue to next case


				case NOT_HANDSHAKING: // application data

					/*
					 * no more handshaking is requested, so end up here. But we are now in stream mode
					 * (handshake is now completed), so ALWAYS ask for more wrapping. 
					 * 
					 * NOTE: if applicationBuffer is depleted, then networkBuffer will remain empty and
					 * wrap() method will stop by itself.
					 */

					switch(wrapResult.getStatus()) {

					case BUFFER_UNDERFLOW: // not supposed to happen
						throw new SSLException("Strange error: BUFFER_UNDERFLOW while wrapping");

						/* 
						 * Handle the <code>wrap(applicationOutput, networkOutput)</code> 
						 * case when the SSLEngine was not able to process the operation 
						 * because there are not enough bytes available in the destination 
						 * buffer to hold the result.
						 */
					case BUFFER_OVERFLOW: handleBufferOverflow(process); break;

					case CLOSED: 
						// close must be detected separately. Left here for security purposes.
						break;


					case OK: 

						// nothing produced, so we don't expect more, so push
						if(wrapResult.bytesProduced()==0) {
							if(getNetworkBuffer().position()>0) {
								process.isRunning = false;
								push();
								break;
							}
							else { // everything has been pushed
								// go back to idle state
								process.isRunning = false;
								break;
							}
						}
						// try to get more before pushing (greedy)
						else { 
							//return this;
							break;
						}
					}
					break; // <NOT_HANDSHAKING>
				} 
				/* </handshake-status> */
			}
			catch (SSLException exception) {	
				if(isVerbose()) {
					System.out.println("[Wrapping]: SSL_Exception causes endpoint to close.");
					exception.printStackTrace();
				}
				// Everything went wrong, so try launching the closing procedure
				getEndpoint().close();
				process.mode = close();
			}
		}
		/*
		 * If closed, immediately fork to a specific closing procedure  
		 */
		else {
			process.mode = close();
		}
	}


	private void handleBufferOverflow(Process process) throws SSLException {
		/* Network output is not even half-filled, so assume that it is 
		 * under-sized 
		 */
		if(!isNetworkBufferHalfFilled()) {
			doubleNetworkBufferCapacity();
			//outbound.then(this); -> retry wrapping
		}
		/*
		 * Network output is almost filled, so best solution is to send. But since we
		 * are in handshaking phase, must return to unsafeWrap once networkBuffer bytes have
		 * been written out
		 */
		else {

			// process is terminated here, another process will be restarted
			process.isRunning = false; 
			
			// NEED_WRAP, so ask to retry wrapping after pushing
			push();
		}
	}

	public boolean isNetworkBufferHalfFilled() {
		ByteBuffer networkBuffer = getNetworkBuffer();
		return networkBuffer.position()>networkBuffer.capacity()/2;
	}



	/**
	 * Double buffer capacity
	 * 
	 * @param engine
	 * @throws SSLException
	 */
	public void doubleNetworkBufferCapacity() throws SSLException {

		ByteBuffer networkBuffer = getNetworkBuffer();

		int increasedCapacity = 2 * networkBuffer.capacity();
		if (isVerbose()) {
			System.out.println("[SSL] "+getName()
			+ " : Network output buffer capacity increased to " + increasedCapacity);
		}
		if (increasedCapacity > 4 * getEngine().getSession().getPacketBufferSize()) {
			throw new SSLException(
					"[SSL_Inbound] networ output capacity is now 4x getPacketBufferSize. " + "Seen as excessive");
		}

		// publish new network buffer
		ByteBuffer extendedBuffer = resizeNetworkBuffer(increasedCapacity);

		networkBuffer.flip();
		extendedBuffer.put(networkBuffer);
		//extendedBuffer.compact(); // left in write mode
	}

}